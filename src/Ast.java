import java.util.List;
import java.util.ArrayList;

/**
 * The abstract syntax tree.
 * The Ast is a tree made up of Instruction objects.
 * An instruction as a then and else branch.
 * The ast takes the full tree generated by the parser and creates the Instruction tree from it.
 */
public class Ast {

    private Instruction root = null;

    public Ast(ParseTree tree) {
        this.root = new Instruction(tree);
    }

    public Instruction getRoot() {
        return this.root;
    }

    private Instruction instanciateInstruction(ParseTree tree) {
        Variable type = tree.getLabel().getVariable();
        switch (type) {
            case ASSIGN:
                return new Assign(tree);
            case IF:
                return new If(tree);
            case WHILE:
                return new While(tree);
            case PRINT:
                return new Print(tree);
            case READ:
                return new Read(tree);
            default:
                return new Instruction(tree);
        }
    }

    /**
     * Goes through the codes and add an instruction in the tree when encounteres a new instruction.
     * @param node: the current layer
     * @param breach: the visitor layer
     * @param isElse: are we in an else block
     */
    public void aggregateInstructions(ParseTree breach, Instruction node, boolean isElse) {
        for (int i = 0; i < breach.numChildren(); ++i) {
            ParseTree e = breach.getChildren().get(i);

            if (e.isInstruction()) {

                List<Instruction> recipient = (isElse) ? node.getElseList() : node.getThenList();
                recipient.add(instanciateInstruction(e.get(0))); // add the operation
            }
            if (e.isIfSeq()) {
                if (e.numChildren() != 1) {
                    e = e.get(1); // the <Code> in instruction 
                    isElse = true;
                }
            }
            if (!e.isLeaf() && e.isCode()) {
                breach.remove(i--); // remove now useless code node from the tree
                aggregateInstructions(e, node, isElse); // visit another code node
            }
        }
    }

    /**
     * Add every instruction in the current layer and deeper layers
     * @param node: the current layer
     * @param breach: the visitor layer
     */
    private void detachFromMainTree(ParseTree breach, Instruction node) {
        aggregateInstructions(breach, node, false);
        for (Instruction n: node.getThenList()) { // do the same on freshly added layers n+1 operations
            detachFromMainTree(n.getTree(), n);
        }
        for (Instruction n: node.getElseList()) { // do the same on freshly added layers n+1 operations
            detachFromMainTree(n.getTree(), n);
        }
    }

    /**
     * Simplify the tree by removing useless nodes
     */
    private void simplify(Instruction instruction) {
        for (Instruction n: instruction.getThenList()) {
            simplify(n);
        }
        for (Instruction n: instruction.getElseList()) {
            simplify(n);
        }
        instruction.simplify();
    }

    /**
     * Create the instruction tree from the parse tree
     */
    public void create() {
        this.detachFromMainTree(root.getTree(), root);
        this.simplify(root);
    }
}
